# Dify SSOå¿«é€Ÿå‚è€ƒæŒ‡å—

> ğŸ“Œ **å¿«é€ŸæŸ¥é˜…**: å¸¸ç”¨å‘½ä»¤ã€é…ç½®å’Œä»£ç ç‰‡æ®µ  
> ğŸ• **æ›´æ–°æ—¥æœŸ**: 2025-11-19

---

## ğŸš€ å¿«é€Ÿå¯åŠ¨å‘½ä»¤

### æ–¹æ¡ˆä¸€å¯åŠ¨

```bash
# 1. å®‰è£…ä¾èµ–
pip install fastapi uvicorn requests pydantic cryptography

# 2. è®¾ç½®ç¯å¢ƒå˜é‡
export DIFY_BASE_URL=http://localhost:5001
export DIFY_SSO_SECRET=your-secret-key

# 3. å¯åŠ¨åç«¯æœåŠ¡
cd docs/SSOå®ç°æ–¹æ¡ˆ/ä»£ç ç¤ºä¾‹/æ–¹æ¡ˆä¸€/
uvicorn website_a_backend:app --host 0.0.0.0 --port 8000 --reload

# 4. è®¿é—®å‰ç«¯
open website_a_frontend.html
```

### æ–¹æ¡ˆäºŒå¯åŠ¨

```bash
# 1. ä¿®æ”¹Difyåç«¯
cp docs/SSOå®ç°æ–¹æ¡ˆ/ä»£ç ç¤ºä¾‹/æ–¹æ¡ˆäºŒ/dify_sso_endpoint.py \
   api/controllers/console/auth/sso_extend.py

# 2. é…ç½®ç¯å¢ƒå˜é‡
echo "SSO_SHARED_SECRET=your-secret-key" >> api/.env
echo "CONSOLE_WEB_URL=http://localhost:3000" >> api/.env

# 3. é‡å¯Dify
cd docker && docker-compose restart

# 4. å¯åŠ¨ç½‘ç«™Aå®¢æˆ·ç«¯
cd docs/SSOå®ç°æ–¹æ¡ˆ/ä»£ç ç¤ºä¾‹/æ–¹æ¡ˆäºŒ/
uvicorn website_a_sso_client:app --reload
```

---

## ğŸ”‘ æ ¸å¿ƒAPIç«¯ç‚¹

### DifyåŸç”ŸAPI

| ç«¯ç‚¹ | æ–¹æ³• | åŠŸèƒ½ | è¯·æ±‚ä½“ |
|------|------|------|--------|
| `/console/api/login` | POST | ç”¨æˆ·ç™»å½• | `{email, password}` |
| `/console/api/logout` | GET | ç”¨æˆ·ç™»å‡º | - |
| `/console/api/refresh-token` | POST | åˆ·æ–°Token | `{refresh_token}` |

### è‡ªå®šä¹‰SSO API (æ–¹æ¡ˆäºŒ)

| ç«¯ç‚¹ | æ–¹æ³• | åŠŸèƒ½ | å‚æ•° |
|------|------|------|------|
| `/console/api/sso/login` | GET | SSOç™»å½•(é‡å®šå‘) | `email, timestamp, signature, redirect` |
| `/console/api/sso/login` | POST | SSOç™»å½•(API) | `{email, timestamp, signature, redirect}` |

---

## ğŸ” ç­¾åç”Ÿæˆä»£ç ç‰‡æ®µ

### Python

```python
import hmac
import hashlib
import time

def generate_sso_signature(email: str, secret: str) -> tuple:
    timestamp = int(time.time())
    message = f"{email}:{timestamp}"
    signature = hmac.new(
        secret.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()
    return timestamp, signature

# ä½¿ç”¨ç¤ºä¾‹
email = "user@example.com"
secret = "your-shared-secret"
timestamp, signature = generate_sso_signature(email, secret)
print(f"Timestamp: {timestamp}")
print(f"Signature: {signature}")
```

### JavaScript

```javascript
async function generateSSOSignature(email, secret) {
    const timestamp = Math.floor(Date.now() / 1000);
    const message = `${email}:${timestamp}`;
    
    const encoder = new TextEncoder();
    const key = await crypto.subtle.importKey(
        'raw',
        encoder.encode(secret),
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
    );
    
    const signature = await crypto.subtle.sign(
        'HMAC',
        key,
        encoder.encode(message)
    );
    
    const hexSignature = Array.from(new Uint8Array(signature))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
    
    return { timestamp, signature: hexSignature };
}
```

---

## ğŸ“ ç¯å¢ƒå˜é‡é…ç½®

### Difyåç«¯ (.env)

```bash
# åŸºç¡€é…ç½®
SECRET_KEY=your-jwt-secret-key-here
EDITION=SELF_HOSTED

# Tokené…ç½®
ACCESS_TOKEN_EXPIRE_MINUTES=60
REFRESH_TOKEN_EXPIRE_DAYS=30

# SSOé…ç½® (æ–¹æ¡ˆäºŒ)
SSO_SHARED_SECRET=your-sso-shared-secret
CONSOLE_WEB_URL=http://localhost:3000

# Redisé…ç½®
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
```

### ç½‘ç«™Aåç«¯ (.env)

```bash
# Difyé…ç½®
DIFY_BASE_URL=http://localhost:5001
DIFY_SSO_SECRET=your-sso-shared-secret

# åŠ å¯†å¯†é’¥ (æ–¹æ¡ˆä¸€)
ENCRYPTION_KEY=your-encryption-key-here
```

---

## ğŸ§ª æµ‹è¯•å‘½ä»¤

### æµ‹è¯•ç™»å½•API (æ–¹æ¡ˆä¸€)

```bash
curl -X POST http://localhost:8000/api/sso/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }'
```

### æµ‹è¯•SSOç«¯ç‚¹ (æ–¹æ¡ˆäºŒ)

```bash
# ç”Ÿæˆç­¾å
python3 << 'EOF'
import hmac, hashlib, time
email = "test@example.com"
secret = "your-shared-secret"
timestamp = int(time.time())
message = f"{email}:{timestamp}"
signature = hmac.new(secret.encode(), message.encode(), hashlib.sha256).hexdigest()
print(f"http://localhost:5001/console/api/sso/login?email={email}&timestamp={timestamp}&signature={signature}")
EOF

# ä½¿ç”¨ç”Ÿæˆçš„URLæµ‹è¯•
curl -L "ç”Ÿæˆçš„URL"
```

---

## ğŸ”§ å¸¸ç”¨ä»£ç ç‰‡æ®µ

### TokenéªŒè¯

```python
from libs.passport import PassportService

def verify_token(token: str) -> dict:
    """éªŒè¯JWT token"""
    try:
        passport = PassportService()
        payload = passport.verify(token)
        return payload
    except Exception as e:
        print(f"TokenéªŒè¯å¤±è´¥: {e}")
        return None
```

### Tokenå­˜å‚¨ (å‰ç«¯)

```javascript
// å­˜å‚¨token
function saveTokens(accessToken, refreshToken) {
    localStorage.setItem('console_token', accessToken);
    localStorage.setItem('refresh_token', refreshToken);
    
    // åŒæ—¶å­˜å‚¨åˆ°Cookie
    document.cookie = `x-token=${accessToken}; path=/; max-age=3600; SameSite=Lax`;
}

// è¯»å–token
function getAccessToken() {
    return localStorage.getItem('console_token') || 
           getCookie('x-token');
}

// æ¸…é™¤token
function clearTokens() {
    localStorage.removeItem('console_token');
    localStorage.removeItem('refresh_token');
    document.cookie = 'x-token=; path=/; max-age=0';
}
```

### è‡ªåŠ¨åˆ·æ–°Token

```javascript
async function refreshAccessToken() {
    const refreshToken = localStorage.getItem('refresh_token');
    if (!refreshToken) {
        throw new Error('No refresh token');
    }
    
    const response = await fetch('/console/api/refresh-token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refresh_token: refreshToken })
    });
    
    const data = await response.json();
    if (data.result === 'success') {
        saveTokens(data.data.access_token, data.data.refresh_token);
        return data.data.access_token;
    }
    
    throw new Error('Token refresh failed');
}
```

---

## ğŸ› æ•…éšœæ’æŸ¥é€ŸæŸ¥è¡¨

| é—®é¢˜ | å¯èƒ½åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|---------|---------|
| 401 Unauthorized | Tokenæ— æ•ˆæˆ–è¿‡æœŸ | åˆ·æ–°tokenæˆ–é‡æ–°ç™»å½• |
| ç­¾åéªŒè¯å¤±è´¥ | å¯†é’¥ä¸åŒ¹é…æˆ–æ—¶é—´æˆ³è¿‡æœŸ | æ£€æŸ¥SSO_SHARED_SECRETé…ç½® |
| CORSé”™è¯¯ | è·¨åŸŸé…ç½®é—®é¢˜ | é…ç½®Dify APIçš„CORSç­–ç•¥ |
| Tokenæœªå­˜å‚¨ | localStorageè¢«ç¦ç”¨ | ä½¿ç”¨Cookieä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ |
| é‡å®šå‘å¤±è´¥ | URLé…ç½®é”™è¯¯ | æ£€æŸ¥CONSOLE_WEB_URLé…ç½® |

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### Redisè¿æ¥æ± 

```python
from redis import ConnectionPool, Redis

pool = ConnectionPool(
    host='localhost',
    port=6379,
    db=0,
    max_connections=50,
    decode_responses=True
)
redis_client = Redis(connection_pool=pool)
```

### Tokenç¼“å­˜

```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def get_user_by_token(token: str):
    """ç¼“å­˜ç”¨æˆ·ä¿¡æ¯"""
    payload = PassportService().verify(token)
    return get_user(payload['user_id'])
```

---

## ğŸ”’ å®‰å…¨æ£€æŸ¥æ¸…å•

- [ ] æ‰€æœ‰é€šä¿¡ä½¿ç”¨HTTPS
- [ ] SECRET_KEYä½¿ç”¨å¼ºéšæœºå¯†é’¥
- [ ] SSO_SHARED_SECRETå®šæœŸè½®æ¢
- [ ] å¯ç”¨é€Ÿç‡é™åˆ¶
- [ ] é…ç½®CORSç™½åå•
- [ ] å¯ç”¨æ—¥å¿—å®¡è®¡
- [ ] Tokenè®¾ç½®åˆç†è¿‡æœŸæ—¶é—´
- [ ] å®ç°Tokenæ’¤é”€æœºåˆ¶

---

## ğŸ“ å¿«é€Ÿè”ç³»

é‡åˆ°é—®é¢˜ï¼ŸæŸ¥çœ‹ä»¥ä¸‹èµ„æºï¼š

1. **å®Œæ•´æ–‡æ¡£**: [Dify-SSOå®Œæ•´å®ç°æ–¹æ¡ˆ.md](./Dify-SSOå®Œæ•´å®ç°æ–¹æ¡ˆ.md)
2. **éƒ¨ç½²æŒ‡å—**: [éƒ¨ç½²æŒ‡å—.md](./éƒ¨ç½²æŒ‡å—.md)
3. **å®‰å…¨æŒ‡å—**: [å®‰å…¨æœ€ä½³å®è·µ.md](./å®‰å…¨æœ€ä½³å®è·µ.md)
4. **æµ‹è¯•ç”¨ä¾‹**: [æµ‹è¯•ç”¨ä¾‹.md](./æµ‹è¯•ç”¨ä¾‹.md)

---

**æœ€åæ›´æ–°**: 2025-11-19  
**ç»´æŠ¤è€…**: Cascade AI

