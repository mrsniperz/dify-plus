# Dify SSO测试用例

> 版本: v1.0.0  
> 更新日期: 2025-11-19

## 目录
- [1. 功能测试](#1-功能测试)
- [2. 安全测试](#2-安全测试)
- [3. 性能测试](#3-性能测试)
- [4. 兼容性测试](#4-兼容性测试)
- [5. 自动化测试脚本](#5-自动化测试脚本)

---

## 1. 功能测试

### 1.1 方案一：API Token传递

#### 测试用例1.1.1: 正常登录流程

**测试目标**: 验证用户可以通过网站A成功登录Dify

**前置条件**:
- Dify服务正常运行
- 网站A后端服务正常运行
- 用户账号已在Dify中注册

**测试步骤**:
1. 打开网站A登录页面
2. 输入有效的邮箱和密码
3. 点击"登录并跳转到Dify"按钮
4. 等待页面跳转

**预期结果**:
- ✅ 显示"登录成功"提示
- ✅ 自动跳转到Dify平台
- ✅ Dify显示已登录状态
- ✅ 用户信息正确显示

**实际结果**: _____

**测试状态**: [ ] 通过 [ ] 失败

---

#### 测试用例1.1.2: 错误凭证处理

**测试目标**: 验证错误凭证的处理

**测试步骤**:
1. 输入不存在的邮箱
2. 点击登录按钮

**预期结果**:
- ✅ 显示"用户不存在"错误提示
- ✅ 不进行跳转
- ✅ 错误信息清晰易懂

**测试状态**: [ ] 通过 [ ] 失败

---

#### 测试用例1.1.3: Token存储验证

**测试目标**: 验证Token正确存储

**测试步骤**:
1. 成功登录后
2. 打开浏览器开发者工具
3. 检查localStorage和Cookie

**预期结果**:
- ✅ localStorage中存在`console_token`
- ✅ Cookie中存在`x-token`
- ✅ Token格式正确（JWT格式）

**验证命令**:
```javascript
// 在浏览器控制台执行
console.log('Access Token:', localStorage.getItem('console_token'));
console.log('Cookies:', document.cookie);
```

**测试状态**: [ ] 通过 [ ] 失败

---

#### 测试用例1.1.4: 页面刷新保持登录

**测试目标**: 验证刷新页面后仍保持登录状态

**测试步骤**:
1. 成功登录Dify
2. 刷新页面（F5）
3. 检查登录状态

**预期结果**:
- ✅ 仍然显示已登录
- ✅ 用户信息未丢失
- ✅ 无需重新登录

**测试状态**: [ ] 通过 [ ] 失败

---

### 1.2 方案二：自定义SSO端点

#### 测试用例1.2.1: GET方式SSO登录

**测试目标**: 验证GET重定向方式登录

**测试步骤**:
1. 访问网站A首页
2. 在"方法1"表单中输入邮箱
3. 点击"直接跳转到Dify"

**预期结果**:
- ✅ 自动跳转到Dify SSO端点
- ✅ Dify验证签名成功
- ✅ 自动登录并跳转到目标页面

**测试状态**: [ ] 通过 [ ] 失败

---

#### 测试用例1.2.2: POST方式SSO登录

**测试目标**: 验证POST API方式登录

**测试步骤**:
1. 在"方法2"表单中输入邮箱
2. 点击"获取Token并跳转"

**预期结果**:
- ✅ 调用后端API成功
- ✅ 返回包含token的响应
- ✅ 自动跳转到Dify前端回调页面
- ✅ Token正确存储并完成登录

**测试状态**: [ ] 通过 [ ] 失败

---

#### 测试用例1.2.3: 签名验证

**测试目标**: 验证签名机制的有效性

**测试步骤**:
1. 手动构造SSO请求
2. 使用错误的签名
3. 发送请求到Dify SSO端点

**预期结果**:
- ✅ 返回401 Unauthorized
- ✅ 错误信息为"SSO签名验证失败"
- ✅ 不生成Token

**测试命令**:
```bash
curl -X GET "http://localhost:5001/console/api/sso/login?email=test@example.com&timestamp=1700000000&signature=invalid" -v
```

**测试状态**: [ ] 通过 [ ] 失败

---

## 2. 安全测试

### 2.1 时间戳过期测试

**测试用例2.1.1: 过期时间戳拒绝**

**测试目标**: 验证过期的时间戳被拒绝

**测试步骤**:
1. 生成10分钟前的时间戳
2. 使用该时间戳生成签名
3. 发送SSO请求

**预期结果**:
- ✅ 请求被拒绝
- ✅ 返回401错误

**测试脚本**:
```python
import time
import hmac
import hashlib

email = "test@example.com"
secret = "your-shared-secret"
timestamp = int(time.time()) - 600  # 10分钟前

message = f"{email}:{timestamp}"
signature = hmac.new(secret.encode(), message.encode(), hashlib.sha256).hexdigest()

print(f"Expired request: timestamp={timestamp}, signature={signature}")
```

**测试状态**: [ ] 通过 [ ] 失败

---

### 2.2 重放攻击测试

**测试用例2.2.1: 相同请求重复发送**

**测试目标**: 验证nonce机制防止重放攻击

**测试步骤**:
1. 生成有效的SSO请求
2. 第一次发送请求（应成功）
3. 立即再次发送相同请求

**预期结果**:
- ✅ 第一次请求成功
- ✅ 第二次请求被拒绝（如果实现了nonce）

**测试状态**: [ ] 通过 [ ] 失败

---

### 2.3 SQL注入测试

**测试用例2.3.1: 邮箱字段SQL注入**

**测试目标**: 验证输入验证防止SQL注入

**测试步骤**:
1. 在邮箱字段输入: `admin' OR '1'='1`
2. 提交登录请求

**预期结果**:
- ✅ 请求被拒绝
- ✅ 返回"无效的邮箱格式"错误

**测试状态**: [ ] 通过 [ ] 失败

---

### 2.4 XSS攻击测试

**测试用例2.4.1: 重定向URL XSS**

**测试目标**: 验证重定向URL的XSS防护

**测试步骤**:
1. 在redirect参数中注入: `javascript:alert('XSS')`
2. 提交请求

**预期结果**:
- ✅ 请求被拒绝或URL被过滤
- ✅ 不执行JavaScript代码

**测试状态**: [ ] 通过 [ ] 失败

---

## 3. 性能测试

### 3.1 并发登录测试

**测试用例3.1.1: 100并发用户登录**

**测试目标**: 验证系统在并发场景下的稳定性

**测试工具**: Apache Bench (ab) 或 Locust

**测试命令**:
```bash
ab -n 100 -c 10 -p login_data.json -T application/json \
   http://localhost:8000/api/sso/login
```

**预期结果**:
- ✅ 所有请求成功率 > 95%
- ✅ 平均响应时间 < 500ms
- ✅ 无服务器错误

**测试状态**: [ ] 通过 [ ] 失败

---

### 3.2 Token生成性能

**测试用例3.2.1: Token生成速度**

**测试目标**: 验证Token生成效率

**测试脚本**:
```python
import time
from services.account_service import AccountService

start_time = time.time()
for i in range(1000):
    token = AccountService.get_account_jwt_token(account)
end_time = time.time()

avg_time = (end_time - start_time) / 1000
print(f"Average token generation time: {avg_time*1000:.2f}ms")
```

**预期结果**:
- ✅ 平均生成时间 < 10ms

**测试状态**: [ ] 通过 [ ] 失败

---

## 4. 兼容性测试

### 4.1 浏览器兼容性

**测试用例4.1.1: 主流浏览器测试**

| 浏览器 | 版本 | 测试状态 | 备注 |
|--------|------|---------|------|
| Chrome | 最新版 | [ ] 通过 [ ] 失败 | |
| Firefox | 最新版 | [ ] 通过 [ ] 失败 | |
| Safari | 最新版 | [ ] 通过 [ ] 失败 | |
| Edge | 最新版 | [ ] 通过 [ ] 失败 | |

---

### 4.2 移动端兼容性

**测试用例4.2.1: 移动浏览器测试**

| 平台 | 浏览器 | 测试状态 | 备注 |
|------|--------|---------|------|
| iOS | Safari | [ ] 通过 [ ] 失败 | |
| Android | Chrome | [ ] 通过 [ ] 失败 | |

---

## 5. 自动化测试脚本

### 5.1 Python测试脚本

```python
"""
SSO自动化测试脚本
"""
import requests
import time
import hmac
import hashlib

BASE_URL = "http://localhost:8000"
DIFY_URL = "http://localhost:5001"
SECRET = "your-shared-secret"

def test_方案一_正常登录():
    """测试方案一正常登录流程"""
    response = requests.post(
        f"{BASE_URL}/api/sso/login",
        json={
            "email": "test@example.com",
            "password": "password123"
        }
    )
    
    assert response.status_code == 200
    data = response.json()
    assert data["success"] == True
    assert "redirect_url" in data
    print("✅ 方案一正常登录测试通过")

def test_方案二_签名验证():
    """测试方案二签名验证"""
    email = "test@example.com"
    timestamp = int(time.time())
    message = f"{email}:{timestamp}"
    signature = hmac.new(
        SECRET.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()
    
    response = requests.get(
        f"{DIFY_URL}/console/api/sso/login",
        params={
            "email": email,
            "timestamp": timestamp,
            "signature": signature
        }
    )
    
    assert response.status_code in [200, 302]
    print("✅ 方案二签名验证测试通过")

if __name__ == "__main__":
    test_方案一_正常登录()
    test_方案二_签名验证()
    print("\n🎉 所有测试通过！")
```

---

## 测试报告模板

### 测试执行总结

- **测试日期**: _____
- **测试人员**: _____
- **测试环境**: _____
- **总用例数**: _____
- **通过数**: _____
- **失败数**: _____
- **通过率**: _____%

### 问题列表

| 编号 | 问题描述 | 严重程度 | 状态 |
|------|---------|---------|------|
| 1 | | | |
| 2 | | | |

