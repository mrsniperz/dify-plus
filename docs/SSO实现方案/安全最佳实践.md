# Dify SSO安全最佳实践

> 版本: v1.0.0  
> 更新日期: 2025-11-19

## 目录
- [1. Token安全](#1-token安全)
- [2. 传输安全](#2-传输安全)
- [3. 防护措施](#3-防护措施)
- [4. 监控与审计](#4-监控与审计)
- [5. 应急响应](#5-应急响应)

---

## 1. Token安全

### 1.1 Token生成

#### 使用强随机数生成器

```python
import secrets

# ✅ 推荐：使用secrets模块
refresh_token = secrets.token_urlsafe(32)

# ❌ 不推荐：使用random模块
import random
token = str(random.randint(1000000, 9999999))  # 不安全
```

#### JWT密钥管理

```python
# ✅ 推荐：从环境变量读取
SECRET_KEY = os.getenv('SECRET_KEY')
if not SECRET_KEY:
    raise ValueError("SECRET_KEY must be set")

# ❌ 不推荐：硬编码
SECRET_KEY = "my-secret-key"  # 不安全
```

### 1.2 Token存储

#### 前端存储策略

| 存储方式 | 安全性 | 适用场景 | 注意事项 |
|---------|--------|----------|----------|
| localStorage | ⭐⭐⭐ | 长期登录 | 易受XSS攻击 |
| sessionStorage | ⭐⭐⭐⭐ | 单次会话 | 关闭标签页即失效 |
| Cookie (HttpOnly) | ⭐⭐⭐⭐⭐ | 推荐 | 需配置SameSite |
| Memory | ⭐⭐⭐⭐⭐ | 高安全 | 刷新页面丢失 |

**推荐方案**：
```javascript
// 短期token存储到sessionStorage
sessionStorage.setItem('access_token', accessToken);

// 长期token存储到HttpOnly Cookie
document.cookie = `refresh_token=${refreshToken}; HttpOnly; Secure; SameSite=Strict; Max-Age=2592000`;
```

#### 后端存储策略

```python
# ✅ 推荐：使用Redis存储refresh_token
redis_client.setex(
    f"refresh_token:{token}",
    timedelta(days=30),
    user_id
)

# ❌ 不推荐：存储在数据库
# 增加数据库负载，且难以快速撤销
```

### 1.3 Token过期策略

```python
# 短期access_token + 长期refresh_token
ACCESS_TOKEN_EXPIRE_MINUTES = 15  # 15分钟
REFRESH_TOKEN_EXPIRE_DAYS = 30    # 30天

# SSO专用短期token
SSO_TOKEN_VALIDITY = 300  # 5分钟，仅用于SSO跳转
```

---

## 2. 传输安全

### 2.1 强制HTTPS

#### Nginx配置

```nginx
server {
    listen 80;
    server_name your-domain.com;
    
    # 强制重定向到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    # SSL证书配置
    ssl_certificate /path/to/fullchain.pem;
    ssl_certificate_key /path/to/privkey.pem;
    
    # SSL安全配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # HSTS
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
}
```

#### 应用层检查

```python
from flask import request, abort

@app.before_request
def check_https():
    if not request.is_secure and not app.debug:
        abort(403, "HTTPS required")
```

### 2.2 Token加密传输

#### URL参数加密

```python
from cryptography.fernet import Fernet

# 生成加密密钥
ENCRYPTION_KEY = Fernet.generate_key()
cipher_suite = Fernet(ENCRYPTION_KEY)

# 加密token
def encrypt_token(token: str) -> str:
    encrypted = cipher_suite.encrypt(token.encode())
    return encrypted.decode()

# 解密token
def decrypt_token(encrypted_token: str) -> str:
    decrypted = cipher_suite.decrypt(encrypted_token.encode())
    return decrypted.decode()
```

### 2.3 敏感数据脱敏

```python
import logging

# ✅ 推荐：脱敏日志
logger.info(f"User login: {email[:3]}***@{email.split('@')[1]}")

# ❌ 不推荐：明文日志
logger.info(f"User login: {email}, token: {access_token}")
```

---

## 3. 防护措施

### 3.1 防止CSRF攻击

#### State参数验证

```python
import secrets

# 生成state参数
state = secrets.token_urlsafe(16)
redis_client.setex(f"sso_state:{state}", 300, user_id)

# 验证state参数
def verify_state(state: str, user_id: str) -> bool:
    stored_user_id = redis_client.get(f"sso_state:{state}")
    if stored_user_id and stored_user_id.decode() == user_id:
        redis_client.delete(f"sso_state:{state}")  # 一次性使用
        return True
    return False
```

#### SameSite Cookie

```python
from flask import make_response

response = make_response(redirect_url)
response.set_cookie(
    'x-token',
    token,
    max_age=3600,
    secure=True,
    httponly=True,
    samesite='Strict'  # 或 'Lax'
)
```

### 3.2 防止XSS攻击

#### 输入验证

```python
from pydantic import BaseModel, EmailStr, validator

class SSORequest(BaseModel):
    email: EmailStr
    redirect_url: str
    
    @validator('redirect_url')
    def validate_redirect(cls, v):
        # 只允许相对路径或白名单域名
        if v.startswith('/'):
            return v
        
        allowed_domains = ['dify.ai', 'your-domain.com']
        from urllib.parse import urlparse
        parsed = urlparse(v)
        
        if parsed.netloc in allowed_domains:
            return v
        
        raise ValueError('Invalid redirect URL')
```

#### 输出转义

```javascript
// 前端：使用textContent而非innerHTML
element.textContent = userInput;  // ✅ 安全
element.innerHTML = userInput;    // ❌ 危险
```

### 3.3 防止重放攻击

#### 时间戳验证

```python
import time

def verify_timestamp(timestamp: int, validity: int = 300) -> bool:
    """
    验证时间戳有效性
    
    Args:
        timestamp: 请求时间戳
        validity: 有效期（秒）
        
    Returns:
        bool: 时间戳是否有效
    """
    current_time = int(time.time())
    return abs(current_time - timestamp) <= validity
```

#### Nonce机制

```python
def verify_nonce(nonce: str) -> bool:
    """
    验证nonce唯一性
    
    Args:
        nonce: 随机字符串
        
    Returns:
        bool: nonce是否有效
    """
    key = f"nonce:{nonce}"
    
    # 检查是否已使用
    if redis_client.exists(key):
        return False
    
    # 标记为已使用
    redis_client.setex(key, 300, "used")
    return True
```

### 3.4 速率限制

```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

@app.route("/sso/login")
@limiter.limit("5 per minute")  # SSO登录限制
def sso_login():
    pass
```

---

## 4. 监控与审计

### 4.1 日志记录

```python
import logging
from datetime import datetime

def log_sso_event(event_type: str, user_email: str, ip_address: str, success: bool):
    """
    记录SSO事件
    
    Args:
        event_type: 事件类型（login/logout/refresh）
        user_email: 用户邮箱
        ip_address: IP地址
        success: 是否成功
    """
    log_data = {
        "timestamp": datetime.utcnow().isoformat(),
        "event_type": event_type,
        "user_email": user_email[:3] + "***",  # 脱敏
        "ip_address": ip_address,
        "success": success
    }
    
    if success:
        logging.info(f"SSO Event: {log_data}")
    else:
        logging.warning(f"SSO Failed: {log_data}")
```

### 4.2 异常检测

```python
def detect_suspicious_activity(user_id: str, ip_address: str) -> bool:
    """
    检测可疑活动
    
    Returns:
        bool: 是否可疑
    """
    # 检查短时间内多次登录
    key = f"login_attempts:{user_id}"
    attempts = redis_client.incr(key)
    redis_client.expire(key, 300)
    
    if attempts > 5:
        logging.warning(f"Suspicious: Multiple login attempts for user {user_id}")
        return True
    
    # 检查IP地址变化
    last_ip_key = f"last_ip:{user_id}"
    last_ip = redis_client.get(last_ip_key)
    
    if last_ip and last_ip.decode() != ip_address:
        logging.info(f"IP changed for user {user_id}: {last_ip.decode()} -> {ip_address}")
    
    redis_client.setex(last_ip_key, 86400, ip_address)
    
    return False
```

---

## 5. 应急响应

### 5.1 Token撤销

```python
def revoke_all_tokens(user_id: str):
    """撤销用户所有token"""
    # 删除所有refresh_token
    pattern = f"refresh_token:*:{user_id}"
    for key in redis_client.scan_iter(match=pattern):
        redis_client.delete(key)
    
    # 加入黑名单
    redis_client.sadd(f"revoked_users:{user_id}", "all")
```

### 5.2 密钥轮换

```bash
# 生成新密钥
NEW_SECRET_KEY=$(python -c "import secrets; print(secrets.token_hex(32))")

# 更新环境变量
echo "SECRET_KEY=$NEW_SECRET_KEY" >> .env

# 重启服务
docker-compose restart
```

### 5.3 安全事件响应流程

1. **发现异常** → 立即暂停SSO服务
2. **分析日志** → 确定影响范围
3. **撤销Token** → 强制所有用户重新登录
4. **修复漏洞** → 更新代码和配置
5. **恢复服务** → 监控异常活动
6. **事后总结** → 更新安全策略

